<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JS笔记 | 穿着校服拽天下</title>
  <meta name="keywords" content=" JavaScript ">
  <meta name="description" content="JS笔记 | 穿着校服拽天下">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;about&#x2F;index.html">
<meta property="og:site_name" content="穿着校服拽天下">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-11-06T06:21:40.643Z">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>穿着校服拽天下</span>
</div>

<div class="icon">
    
        
        <a title="github" href="https://github.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
        <a title="jianshu" href="https://www.jianshu.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-jianshu"></use>
                </svg>
            
        </a>
        
    
        
        <a title="oschina" href="https://my.oschina.net" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-oschina"></use>
                </svg>
            
        </a>
        
    
        
    
        
        <a title="email" href="mailto:1499641973@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1499641973&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(20)</small></div></li>
    
        
            
            <li><div data-rel="笔记">笔记<small>(19)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="20">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="Search..." autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color2">H5+CSS</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color4">git</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color4">API</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color3">规范</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color3">框架</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color3">面试</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color3">JS</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color4">Vue</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color5">ajax</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color3">Js</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color5">code</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color1">React</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color3">Webpack</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color1">Other</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color4">VUE</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color5">前端路由</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" target="_blank" rel="noopener" class="color1">JavaScript</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class="笔记 "
           href="/2019/11/06/cmd%E6%8F%92%E4%BB%B6.%E8%B7%AF%E5%BE%84/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="插件、路径">插件、路径</span>
            <span class="post-date" title="2019-11-06 14:37:08">2019/11/06</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/06/biji/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="重点总结">重点总结</span>
            <span class="post-date" title="2019-11-06 14:37:08">2019/11/06</span>
        </a>
        
        <a  class=""
           href="/2019/11/06/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2019-11-06 13:14:08">2019/11/06</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/06/api/"
           data-tag="API"
           data-author="" >
            <span class="post-title" title="API接口文档">API接口文档</span>
            <span class="post-date" title="2019-11-06 14:37:08">2019/11/06</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/06/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"
           data-tag="规范"
           data-author="" >
            <span class="post-title" title="开发规范">开发规范</span>
            <span class="post-date" title="2019-11-06 14:37:08">2019/11/06</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/06/%E6%A1%86%E6%9E%B6/"
           data-tag="框架"
           data-author="" >
            <span class="post-title" title="框架">框架</span>
            <span class="post-date" title="2019-11-06 14:37:08">2019/11/06</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/06/%E9%9D%A2%E8%AF%95%E9%A2%98/"
           data-tag="面试"
           data-author="" >
            <span class="post-title" title="重点要点">重点要点</span>
            <span class="post-date" title="2019-11-06 14:37:08">2019/11/06</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/06/JavaScript/"
           data-tag="JavaScript"
           data-author="" >
            <span class="post-title" title="JS笔记">JS笔记</span>
            <span class="post-date" title="2019-11-06 14:37:08">2019/11/06</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/06/H5+CSS/"
           data-tag="H5+CSS"
           data-author="" >
            <span class="post-title" title="H5+CSS">H5+CSS</span>
            <span class="post-date" title="2019-11-06 14:37:08">2019/11/06</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/12/Vuex/"
           data-tag="Vue"
           data-author="" >
            <span class="post-title" title="VueX">VueX</span>
            <span class="post-date" title="2019-11-12 14:07:09">2019/11/12</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/12/ajax/"
           data-tag="ajax"
           data-author="" >
            <span class="post-title" title="ajax">ajax</span>
            <span class="post-date" title="2019-11-12 14:06:36">2019/11/12</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/12/code/"
           data-tag="code"
           data-author="" >
            <span class="post-title" title="状态码">状态码</span>
            <span class="post-date" title="2019-11-12 14:07:42">2019/11/12</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/12/array/"
           data-tag="Js"
           data-author="" >
            <span class="post-title" title="数组">数组</span>
            <span class="post-date" title="2019-11-12 14:08:31">2019/11/12</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/12/webpack%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"
           data-tag="Vue"
           data-author="" >
            <span class="post-title" title="webpack搭建">webpack搭建</span>
            <span class="post-date" title="2019-11-12 21:09:46">2019/11/12</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/06/React/"
           data-tag="React"
           data-author="" >
            <span class="post-title" title="React">React</span>
            <span class="post-date" title="2019-11-06 14:37:08">2019/11/06</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/06/Webpack/"
           data-tag="Webpack"
           data-author="" >
            <span class="post-title" title="Webpack">Webpack</span>
            <span class="post-date" title="2019-11-06 14:37:08">2019/11/06</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/06/other/"
           data-tag="Other"
           data-author="" >
            <span class="post-title" title="Other">Other</span>
            <span class="post-date" title="2019-11-06 14:37:08">2019/11/06</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/06/JS/"
           data-tag="JS"
           data-author="" >
            <span class="post-title" title="JS">JS</span>
            <span class="post-date" title="2019-11-06 14:37:08">2019/11/06</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/06/Vue/"
           data-tag="VUE"
           data-author="" >
            <span class="post-title" title="VUE">VUE</span>
            <span class="post-date" title="2019-11-06 14:37:08">2019/11/06</span>
        </a>
        
        <a  class="笔记 "
           href="/2019/11/06/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"
           data-tag="前端路由"
           data-author="" >
            <span class="post-title" title="前端路由">前端路由</span>
            <span class="post-date" title="2019-11-06 14:37:08">2019/11/06</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-JavaScript" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">JS笔记</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a href="javascript:" target="_blank" data-rel="笔记 noopener">笔记</a>
            
        </span>
        
        
        <span class="tag">
            
            <a href="javascript:" target="_blank" rel="noopener" class="color1">JavaScript</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2019-11-13 21:02:46'>2019-11-06 14:37</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JS第一课</p>
<p>浏览器发展简史</p>
<p>1991年 WorldWideWeb  1994年Netscape （网景）→ 2002年IE主导浏览器市场  </p>
<p>2003年Safari  2004年Firefox  2008年Chrome → ……</p>
<p>JavaScript的诞生</p>
<p>1995年Brendan Eich(布兰登·艾奇)创造了JavaScript 仅用10天</p>
<p>*注意JS引擎（V8  SpiderMonkey ）</p>
<p>js的基础介绍</p>
<ul>
<li>js的组成<ul>
<li>ECMAscript</li>
<li>BOM</li>
<li>DOM</li>
</ul>
</li>
</ul>
<p>数据类型</p>
<ul>
<li>javascript的数据类型<ul>
<li>数值 </li>
<li>字符串</li>
<li>布尔值</li>
<li>undefined </li>
<li>null </li>
<li>对象</li>
</ul>
</li>
<li>JavaScript的数据类型转换<ul>
<li>显性转换</li>
<li>隐性转换</li>
</ul>
</li>
</ul>
<pre><code>JavaScript得组成：
ECMAScript      DOM     BOM

变量的声明和定义
var  a = 10;
var是关键字， a是变量名， =是赋值符号 10是值

变量的命名规则
变量是由数字、字母、下划线（_）和美元符号（$）的一种或者几种组成，且不能以数字开头,严格区分大小写。

JS执行方法：
alert(&apos;弹出警告窗&apos;)；
console.log(&apos;哈哈哈&apos;)；在控制台打印

定义变量：
var a = 1;把1赋值给a
let a = 1;

parseInt  一个小数只取整数部分  
var tian = parseInt(89/24);

% 一个小数取小数部分
var c = 89%24;

保留两位小数，并四舍五入
console.log(a.toFixed(2））

布尔值：ture真的   flase假的        
console.log(typeof 名字)查看数据类型


定义没有赋值会出现undefined;
null的类型是空类型object;
对象写法：
let obj = new Object();
obj.name/age/sex  =  ...;

方法：
obj.playball = function(){
    console.log(&apos;&apos;)
}</code></pre><p>1 ：六种数据类型</p>
<pre><code>//基本数据类型：
 数字（Number）   字符串(String)   布尔值（Boolean）   未定义（undefined）   NULL(基础数据，原始数据类型)

//引用数据类型：
 对象（Object）   </code></pre><p>2 ：类型转换</p>
<pre><code>在控制台中黑色表示字符串   蓝色表示数字
数字类型是不加引号，字符串是加引号//////////////重点

console.log(1+2)//3    显示转换
console.log(1+&apos;2&apos;)//12  隐式转换
//字符串转数字
console.log(parseInt(&apos;11&apos;)) //int整数
console.log(parseInt(&apos;11.2&apos;))
console.log(parseFLOAT(&apos;11.2&apos;)) //float浮点数 小数
console.log(number(&apos;11&apos;))//转为数字
console.log(number(&apos;11.2&apos;))

//数字转字符串
var num = 1;
var str = String(num)
console.log(str)

//任意值转布尔
console.log(Boolean(1))
内容为数字，转true
内容为空值，null,underfined 都为false   只有这三个值传的为假


//隐式转换
以下把数字转换为字符串
console.log(1+&apos;2&apos;)//12
console.log(1+1+&apos;2&apos;)//22
console.log(1+&apos;2&apos;+1)//121
console.log(1+&apos;2&apos;+1*4)//124

//以下把字符串转换为数字
console.log(1-&apos;2&apos;)//-1

转为数字比大小
console.log(1&gt;&apos;2&apos;)//比大小
console.log(&apos;12&apos;&gt;&apos;2&apos;)//相同字符串比大小，从左到右，比同一个位置的大小，以此类推


自增自减
let i = 0;
i = i + 1
i+=1;
++写在哪里都是让变量+1；
i++;//1
++i;//1</code></pre><p>2 . 1) :  显式转换</p>
<p>2 . 1. 1) :  把字符串转换为数字</p>
<pre><code>var num1 = parseInt();   //把字符串转换成整数数值（只取整数部分）

parseFloat();    //把字符串直接转换成浮点数（小数）

number();     //把字符串直接转换成数字（只有纯数字菜能转换，如果里面包含字母，就直接转换为NAN【不是数字】）</code></pre><p>2 . 1. 2) :  把数字转换为字符串</p>
<pre><code>console.log(string(num));     //直接转换为字符串

console.log(booLean(0));      //转换为布尔值，只有值为0，输出false，其他值输出为true</code></pre><p>2 . 2) :  隐式转换</p>
<p>3 ：运算符</p>
<pre><code>算数运算符
+    -     *     /      %
加   减    乘    除    取小数/取余


赋值运算符
运算符        例子          等同于
=            x = y         x = y
+=           x += y        x = x + y
-=           x -= y        x = x - y
*=           x *= y        x = x * y
/=           x /= y        x = x / y
%=           x %= y        x = x % y


关系运算符
&gt;    大于
&lt;    小于  
&gt;=   大于等于
&lt;=   小于等于
!=   用于判断是否相等，不光比较数值，还比较类型
!==  只判断数字是否不相等
==   全等，精确相等，判断等号前后是否完全一致，不光比较数值，还比较类型
===  等值等型


逻辑运算符
逻辑与&amp;&amp;   and  和       同真则真  一假则假
逻辑与||   or   或       同假则假  一真则真
逻辑非！   not  取反数    


类型运算符
typeof    返回变量的类型
instanceof     返回true</code></pre><p>3 . 1) :  NaN(字符串转换类型)</p>
<pre><code>隐式转换  Number:
isNaN用来判断转换后的类型是否为NaN

console.log(parseInt(&apos;12px&apos;))//传出12
console.log(parseInt(&apos;aa12px&apos;))//传出NaN   NaN不是数字类型
console.log(Number(&apos;12px&apos;))//传出NaN  NaN不是数字类型

console.log(( NaN == NaN)//传出false
console.log((typeof NaN)//传出number  转换为数字类型
console.log((typeof typeof NaN)//传出string   字符串的值
console.log(typeof typeof 1)//string 
console.log(typeof typeof null)//string 
console.log(isNaN(NaN))//true  对的

console.log(isNaN(1))//false 错的
console.log(isNaN(&apos;11&apos;))//false

console.log(1-&apos;2&apos;)//2   如果符号是+，浏览器可能会把两边当成字符串，如果是-*/，则是运算符</code></pre><p>3 . 2) :  三目运算符</p>
<pre><code>//表达式  { 表达1？ 表达2：表达3  }
//如果表达式为1 为 true，表达式2的值就是整个式子的值，反之表达3的值就是整个式子的值
例子如下：
var a = 1
let b = 0
b = a==1 ?2 : 3
console.log(b)</code></pre><p>4 ：变量</p>
<p>4 . 1) :  关键字</p>
<pre><code>//一组特定用途的关键字
var, if, else, do, while, for, in...
var,let用于定义常量，使用了let定义变量不能重复，使用const定义的叫常量，定义之后不能改变</code></pre><p>4 . 2) :  保留字</p>
<pre><code>未来有可能成为关键字、</code></pre><p>4 . 3) :  变量命名规则</p>
<pre><code>右数字，字母，下划线和$的一种或几种组成，不能以数字开头，严格区分大小写</code></pre><p>函数</p>
<pre><code>函数是一种可以反复调用的代码块

可以提高代码的可读性和复读性

参数的声明//////////////////

函数名后面是一对圆括号，里面是传入函数的参数
function 函数名称(参数列表){
    函数体中的代码;
}
函数定义的时候的参数，称为形参
function print(s) { 
  console.log(s);
}
function add(a,b) { 
  console.log(a+b);
}
参数的传递
    print（1）；

调用函数的时候，传入了 参数  1，1的值给了形参s。
函数调用时候传入的参数叫做实参



////////////////////////函数的返回值///////////////////////
JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值,后面即使还有语句，也不会得到执行。
也就是说，return语句所带的那个表达式，就是函数的返回值。
function add(x, y) {-------------
  return x + y; //返回x+y的和
}
var res = add(1, 1) ;//把函数的返回值 赋值给 变量res
console.log(res);//2

------------------------------------------------------------------------------------------------


arguments
由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。
arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。
var f = function (one) {
  console.log(arguments[0]);
  console.log(arguments[1]);
  console.log(arguments[2]);
}

f(1, 2, 3)
通过arguments对象的length属性，可以判断函数调用时到底带几个参数。


------------------------------------------------------------------------------------------------


变量的声明提升////////////////////
函数内部会产生“变量提升”现象。在函数内部使用var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。
function foo(x) {
  if (x &gt; 100) {
    var tmp = x - 100;
  }
}
// 等同于
function foo(x) {
  var tmp;
  if (x &gt; 100) {
    tmp = x - 100;
  };
}


------------------------------------------------------------------------------------------------


/////////////////////////命令//////////////////////////////////


（1）function命令
function print(){
    console.log(1);
}
print()调用函数

上面的代码命名了一个print函数，以后使用这个函数就可以直接调用相应的代码，这叫做函数的的命名

（2）函数表达式
除了用function命令声明函数，还可以采用变量赋值的写法。
var print = function(){
    console.log(1);
}
这种写法将一个匿名函数（没有名字的函数）赋值给变量。

（3）赋值式函数
let print = function(){  //匿名函数
    console.log(123)
}

(4)立即执行函数
test();
(function(){
    console.log(&apos;132&apos;)
})()

(5)穷举法
    拥有很多种情况
只适合三个数用，平常基本不用</code></pre><p>1 : 程序的基本结构</p>
<pre><code>顺序结构
    从上到下依次

逻辑分支（选择）结构
    if判断
    swith判断

循环结构
//累计  求乘积
1.while  循环
    let i = 50;
    while(i &lt; 501){
        console.log(i);
        i++;
    }
2.do while  循环（do语句，while循环）
//先执行一次  再去判断条件
//至少执行一次
let j=0;
do{
    console.log(j)
    j++
}while(j&lt;10)
3.for  循环  for(初始化表达式；条件；递增表达式){}
//最常用  里面可以套很多层
for(var i=0;i&lt;10;i++){
    console.log(i)//0-9
}</code></pre><p>1 . 1) :  循环</p>
<pre><code>循环分为：
while 循环

do while  循环
//先执行一次  再去判断条件
//至少执行一次

for  循环
//最常用  里面可以套很多层

死循环：
while(1){
    console.log(1)
}

break；  //结束整个循环.
continue;  //结束当前的某一次的循环</code></pre><p>1 . 2) :  小案例</p>
<pre><code>九九乘法表：
for(i=1;i&lt;10;i++){
    for(a=1;a&lt;=i;a++){
        document.write(a+&apos;*&apos;+i+&apos;=&apos;+i*a)
    }
    document.write(&quot;&lt;br/&gt;&quot;)
}

打印三角形：
for(i=0;i&lt;10;i++){
    for(a=0;a&lt;i;a++){
        document.write(&apos;*&apos;)
    }
    document.write(&apos;&lt;br&gt;&apos;)
}

1+2!+3!+...+20!的值：
var a = 1;
var b = 0;
for(i=1;i&lt;=20;i++){
    a = a * i;
    b = a + b;
}
console.log(a)

100-999之间的水仙花数。 abc == a³+ b³+ c³(for)
for(i=100;i&lt;999;i++){
    var c = i%10;//个位
    var a = parseInt(i/100)%10;//百位
    var b = parseInt(i/10)%10;//十位
    var d = a**3+b**3+c**3;
    if(i == d){
        console.log(i)
    }
}

计算100的阶乘(for)：
for(a = 1,i=2;i&lt;=100;i++){
    a = a * i;
}
console.log(a)</code></pre><p>1 . 3) :  arguments参数</p>
<pre><code>arguments                保存了所有的实参
arguments.length         参数的个数
arguments.【&apos;length&apos;】    参数的个数</code></pre><p>1 . 4) :  作用域</p>
<pre><code>    作用域（scope）指的是变量存在的范围

全局作用域：  函数外部声明的变量，，，变量在整个程序中一直存在，所有地方都可以读取；    形参就是局部变量
局部作用域：  在函数内部定义的变量，外部无法按读取，，，变量只在函数内部存在

例：
var v = 1;//全局变量
function f() {

  var b = 2;//局部变量
  console.log(b);
  console.log(v);//它在函数内部可以读取全局变量，但是局部变量的不能再函数外部访问}
f()
上面的代码表明，函数f内部可以读取全局变量v。


函数内部定义的变量，会在该作用域内覆盖同名全局变量。（山高皇帝远，县官不如现管）
例：
 var v = 1;
    function f(){
    var v = 2;
    console.log(v);
 }</code></pre><p>2 : 递归函数</p>
<pre><code>函数可以调用自身，这就是递归。
递归步骤：
//1.先找临界值，即无需计算 就能获取的值       
//2.找本次 和上一次的关系  f（n） = f(n-1)+n  (数学归纳)
//3.假设 当前函数已经可以使用了，调用自身计算上一次的运行结果，再写出本次运行结果 即可

例：
求1-n之间的和
1 ........ 100
1-  1000
1. 临界值1
2. sum(n-1)+n = sum(n)
  function sum1(n) {
            //临界值
            if(n==1){
                return 1;
            }
            return sum1(n-1)+n;
        }

递归   阶加：   从1加到100；
function f(n){
    if(n==0 || n==1){
        return 1;
    }
    return f(n-1)+n;
}
console.log(f(5))

递归   阶乘：   从1乘到100；
function f(n){
    if(n==0 || n==1){
        return 1;
    }
    return f(n-1)*n;
}
console.log(f(5))

递归    斐波那契数列
function f(n){
    if(n==0 || n==1){
        return 1;
    }
    return f(n-1)+f(n-2);
}
console.log(f(5))</code></pre><p>2 . 1) :  构造函数及对象类型(了解)</p>
<pre><code>面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。

面向对象编程的第一步，就是要生成对象。对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成

JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。

构造函数就是一个普通的函数，但是有自己的特征和用法。


////////////////////////////////////////案例/////////////////////////////

首字母大写的函数 都是构造函数
function Dog(name){
    //创建一个空对象
    //{}
    console.log(this)
     //属性  方法
    //给对象增加了name属性
    this.name = name;
    this.age = 0
    console.log(this)

    //属性-&gt; 方法，函数
    this.run = function(){
        //方法内部   this  也是函数创建的方法
        console.log(&apos;汪汪&apos;+this.name)
    }
    //构造函数，默认返回了this对象
    //return this
}
let xiaohei = new Dog(&apos;小黑&apos;)
console.log(xiaohei)
xiaohei.run()

let xiaobai = new Dog(&apos;小白&apos;)
console.log(xiaobai)
xiaobai.run()</code></pre><p>2 . 1) :  函数返回值</p>
<pre><code>返回值：在函数内部有return关键字，并且在关键字后面有内容，这个那日容被返回了</code></pre><p>数组</p>
<p>1 : 定义</p>
<pre><code>/数组：一组相同类型的有序的数据
//数组的作用：可以一次性存储多个数据
//数组的定义：
1）.通过构造函数创建数组
语法：
var 数组名=new Array();
var array=new Array();//定义了一个数组，空数组
数组的名字如果直接输出，那么直接可以把数组中的数据显示出来，如果没有数据就看不到数据

var 数组名=new Array(长度);
如果数组中没有数据，但是有长度~~~，数组中的每个值就是undefined

例：
var array=new Array(5);//没有数据，空数组，5表示数组的长度为5
console.log(array);
alert(array);

2).通过字面量的方式创建数组
var 数组名=[];//空数组

例：
var arr=[];
console.log(arr);</code></pre><p>1 . 1) :  创建对象</p>
<pre><code>/1.字面量方法

//创建数组
var a = 1;
var arr = [1,2,3,4,5]
console.log(arr[0])//下标  索引
console.log(arr[10])//数组越界

//数组遍历
就是对数组所有元素进行访问，比如你要输出数组里所有的信息时，就要用到。
for(let i=0;i&lt;arr2.length;i++){
    console.log(i,arr2[i],arr2[i].username)
}</code></pre><p>1 . 2) :   形参与实参</p>
<pre><code>形参：函数在定义的时候小括号里的变量交形参
实参：函数在调用的时候小括号里传入的值叫实参，实参可以是变量，也可以是值</code></pre><p>2 : 数组常用方法增删改查</p>
<pre><code>//增   一次可以删除多个
1. push  尾部添加(改变原数组)
var arr = [1，2，3]    
    arr.push(4)
    arr.push(&apos;a&apos;)
    console.log(arr)

pop  尾部删除(改变原数组)
var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]    
    arr.pop(&apos;c&apos;);
    console.log(arr)


2. unshift  头部添加(改变原数组)
arr = [1,2,3,4,5,6]
    console.log(arr.unshift(5))
    console.log(arr)

shift 头部删除(改变原数组)
var arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]    
    arr.shift();
    console.log(arr)



push和shift结合使用,构成“先进先出”的队列结构（queue）
push和pop结合使用,构成“后进后出”的栈结构(stack)


3.concat  合并数组(不改变原数组)
var arr6 = [1,3]
var arr7 = [2,4]
let res7 = arr6.concat(arr7)
console.log(arr6)
console.log(res7)
consolee.log(arr6.concat(1，2，arr7)


//复制   slice/splice
/arr.slice(start,end)(不改变原数组)
1.第一个参数是0开始位置，第二个参数为终止位置
2.没有参数等于返回一个元素组的拷贝
3.如果参数为负值，则位置相反，从最后一个开始

/splice 删除并添加(改变原数组)
   splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。q
   其实位置如果是负数，表示从倒数位置开始删除

var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];
a.splice(4, 2) // [&quot;e&quot;, &quot;f&quot;]
a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
上面代码从原数组4号位置，删除了两个数组成员。

var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];
a.splice(4, 2, 1, 2) // [&quot;e&quot;, &quot;f&quot;]
a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2]
上面代码除了删除成员，还插入了两个新成员。



//颠倒元素   reverse/sort
arr9 = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;]
arr9.reverse()
console.log(arr9)

//排序   sort
arr1 = [5,1,3,2,4]
1.默认 字典 升序，就是比较每一个元素的第一个字符的先后顺序
arr1.sort()
console.log(arr1)

2.升序
arr1.sort(function(a,b){
    return a - b
})
console.log(arr1)


//连接   join
console.log(arr9.join(&apos;-&apos;))//连接成一个字符串
如果数组成员是undefined或null空位,会被转成空字符串



//JSON表示的对象
json(将数组转换为字符串)
let obj = {
    &quot;username&quot;:&quot;李现&quot;，
    age:18,
    sex:&apos;男&apos;
    text:function(){
    //方法被谁调用 this  就是谁.
    console.log(obj.username)
    console.log(this.username)
}}
obj.test()


//堆和栈    就是内存
定义变量 占用内存 



//for-in循环
var arr = [1,2,,3,undefined,4,null]
for(i=0;i&lt;arr.length;i++){
    console.log(arr[i])
}
不能遍历空位置
for(let i in arr){   //i是下标也是形参，in是固定的，arr是数组
    console.log(i,arr[i])
}
var obj = {username:&apos;张三&apos;,age:18};
for(let prop in obj){
    // prop是属性名， 都是字符串
    console.log(prop)
    console.log(obj[prop])
}


//一维数组
var arr = [1,2,3,4,5]
console.log(arr)

//二维数组
let arr2 = [
    [&apos;a&apos;,&apos;b&apos;],
    [&apos;d&apos;,&apos;p&apos;]
]
for(i=0;i&lt;arr2.length;i++){
    tmpArr = arr2[i]
    for(j=0;j&lt;tmpArr.length;j++){
        console.log(tmpArr[j])
    }
}

//三维数组
let arr3 = [
    {
        name:&quot;iphone7&quot;,
        colors:[&apos;红色&apos;，&apos;黑色&apos;]
    }
]</code></pre><p>2 . 1) :  数组常用简单方法</p>
<pre><code>/快速查找元素的索引号
1.indexOf  从前往后查
var arr = [1,2,3,4,5]
console.log(arr.indexOf(5));

1.lastIndexOf  从后往前查
var arr = [1,2,3,4,5]
console.log(arr.lastIndexOf(5));</code></pre><p>ES5严格模式</p>
<p>1 : 创作域</p>
<pre><code>正常模式下有两种作用域：全局作用域和函数作用域。
严格模式有第三种作用域：eval作用域，eval所生成的变量只能用于eval内部</code></pre><p>1 . 1) :  实例（对象）方法</p>
<pre><code>map方法把数组的所有成员依次传入参数函数，然后把每一次的执行结构组成一个新数组返回。
var numbers = [1, 2, 3];
var res = numbers.map(function (n) {
  return n + 1;
});
res// [2, 3, 4]
numbers
// [1, 2, 3]

map方法接受一个函数作为参数。该函数迪奥应时，map方法向它传入三个参数：当前成员，当前位置和数组本身。[1, 2, 3].map(function(elem, index, arr) {
  return elem * index;
});
// [0, 2, 6]

filter()
filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回
var res = [1, 2, 3, 4, 5].filter(function (elem, index, arr) {
  return index % 2 === 0;
});
res// [1, 3, 5]

reduce方法依次处理数组的每个成员，最终累计为一个值。reduce是从左到右处理（从第一个成员到最后一个成员）
reduce方法参数是一个函数,该函数接受以下两个参数。
1累积变量，默认为数组的第一个成员
2当前变量，默认为数组的第二个成员
var res = [1, 2, 3, 4, 5].reduce(function (a, b) {
  console.log(a, b);
  return a + b;
})
// 1 2
// 3 3
// 6 4
// 10 5
res//最后结果：15</code></pre><p>1 . 2) :  字符串的创建</p>
<pre><code>var s1 = &apos;abc&apos;
var s2 = new String(&apos;abc&apos;);
typeof s1 // &quot;string&quot;
typeof s2 // &quot;object&quot;
上面代码中，变量s1是字符串，s2是对象。
所以,String对象也叫包装对象
除了用作构造函数，String对象还可以当作工具方法使用，将任意类型的值转为字符串。
String(true) // &quot;true&quot;
String(5) // &quot;5&quot;
上面代码将布尔值ture和数值5，分别转换为字符串</code></pre><p>2 : Math/Date</p>
<pre><code>Math是JavaScript的原生对象，提供各种输血功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用

//数学常数
Math.E    常数e
Math.PI   常数Pi
Math.abs  返回参数值得绝对值

//max/min
Math.max  返回参数中最大的值
Math.min  返回参数中最小的值
console.log(Math.max(...arr))
console.log(Math.min(...arr))

如果参数为空，返回infinity，用于存放参数之中最大的那个值
Math.max返回-Infinity。
Math.min返回Infinity。

//floor
Math.floor方法小于参数值的最大整数（地板值）
例：
Math.floor(3.2)//3
Math.floor(-3.2)//-4
Math.ceil方法大于参数值的最大整数（天花板值）
例：
Math.ceil(3.2)//4
Math.ceil(-3.2)//-3

//round
Math.round方法用于四舍五入。
Math.round(0.1) // 0
Math.round(0.5) // 1
Math.round(0.6) // 1

Math.round(-1.1) // -1
Math.round(-1.5) // -1
Math.round(-1.6) // -2

//Math.pow方法返回第二个元素是第一个元素的平方
Math.pow(2, 2) // 4
Math.pow(2, 3) // 8

//Math.sqrt方法返回参数值的平方根。如果参数是一个负值，则返回NaN。
Math.sqrt(4) // 2
Math.sqrt(-4) // NaN</code></pre><p>2 . 1) :  勾股定理</p>
<pre><code>a^2+b^2=c^2</code></pre><p>2 . 2) :  三角函数</p>
<pre><code>Math.sin()：返回参数的正弦（参数为弧度值）
Math.cos()：返回参数的余弦（参数为弧度值）
Math.tan()：返回参数的正切（参数为弧度值）

30*Math.PI/180   角度转为弧度

Math.sin(0) // 0
Math.cos(0) // 1
Math.tan(0) // 0

Math.sin(Math.PI / 2) // 1</code></pre><p>2 . 3) :  随机数(Math.random)</p>
<pre><code>Math.random()返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。

Math.random() // 0.7151307314634323

任意范围的随机整数生成函数如下。

function getRandomInt(min, max) {
  return parseInt(Math.random() * (max - min + 1)) + min;
}
getRandomInt(1, 6) // 5</code></pre><p>3 : 定时器</p>
<pre><code>setInterval (func,time)
有两个参数，第一个参数是一个函数，第二个参数是时间间隔，单位是毫秒每间隔time秒，会执行一次函数
setInterval的返回值是一个数字
function box(){
    console.log(1)
}
var timer = setInerval(box,1000);
上面代码的意思是，每间隔1000毫秒，box函数执行一次

如果想取消定时器就要拿到setInerval定时器函数的返回值，调用clearInterval，清除定时器clearInterval（timer），调用之后box函数就不会再执行了！</code></pre><p>4 : Date日期</p>
<pre><code>/Date对象是 JavaScript 原生的时间库。它以1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）

var today = new Date();//显示今天的时间
// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</code></pre><p>4 . 1) :  返回时间值</p>
<pre><code>var a = new Date();
    console.log(a)

var b = a.getDate();
    console.log(b)

//在上面先输出一个现在的中国标准时间，然后再下下面的
Date.getDate()              返回一个月中的某一天 (1 ~ 31)
Date.getDay()               返回一周中的某一天 (0 ~ 6)
Date.getMonth()             返回月份 (0 ~ 11)
Date.getFullYear()          以四位数字返回年份
Date.getHours()             返回当前小时（0-23）
Date.getMinutes()           返回当前分钟 (0 ~ 59)
Date.getSeconds()           返回当前秒(0 ~ 59)
Date.getMillisenconds()     返回当前毫秒(0 ~ 999)

注意，月份从0开始计算，但是，天数从1开始计算。另外，除了日期的默认值为1，小时、分钟、秒钟和毫秒的默认值都是0。</code></pre><p>4 . 2) :  返回日期和时间</p>
<pre><code>getDate()            返回一个月中的某一天（1-31）
getDay()            返回一周中的某一天（0-6）0代表周一
getMonth()            返回月份（0-11）0代表一月
getFullYear()        返回年份（四位数）
getHours()            返回当前小时（0-23）
getMinutes()        返回当前分钟（0-59）
getSeconds()        返回当前秒（0-59）
getMillisenconds()     返回当前毫秒（0-999）
getTimes()            返回1970年至今的毫秒数

这些参数如果超出了正常范围，会被自动折算到下一月。</code></pre><p>4 . 3) :  日期的运算</p>
<pre><code>类型自动转换时，
//Date实例如果转为数值，则等于对应的毫秒数；
//如果转为字符串，则等于对应的日期字符串。
所以，
//两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；
//进行加法运算时，返回的是两个字符串连接而成的新字符串。

var d1 = new Date(2000, 2, 1);
var d2 = new Date(2000, 3, 1);

d2 - d1
// 2678400000
d2 + d1
//Wed Aug 28 2019 20:42:47 GMT+0800 (中国标准时间)Wed Aug 28 2019 09:57:42 GMT+0800 (中国标准时间)</code></pre><p>5 : 日期之间的格式转换</p>
<pre><code>//获取现在的标准中国时间
console.log(date)    

//静态方法  获取相对于1970年的毫秒数或字符戳1566981196365
console.log(Date,now())      

//日期的字符串转换为中国标准时间格式的
var str = &apos;2019-08-28T01:57:42.968Z&apos;
    var d2 = new Date(str)
    console.log(d2)

var m = Date.now()-d2.getTime()
    console.log(m/1000/60/60)
//以上两行是用现在的时间减去上面d2的时间然后再转换成小时
console.log(Math.ceil(m/1000/60/60)+&apos;小时前&apos;)//向上舍入成整数

//转换成字符串格式
console.log(d2.toString())

//时间戳转换为日期对象
console.log(new Date(1566981196365))

/以中国标准日期格式打印
//设置日期参数的时候,如果参数过大,自动折算
d3.setFullYear(2018)//当前年
d3.setMonth(d3.getMonth()+12)//当前月+12
d3.setFullYear(d3.getFullYear() +10)//在当前年+10
d3.setDate(d3.getDate()+3)//在当前日+3，如果添加的参数大于当前月则自动补全到下一月
console.log(d3)//打印

/以‘2019年08月28日’这个格式打印
var y = d3.getFullYear()
var m = d3.getMonth()
    if(m&lt;10){
        m = &apos;0&apos; +m
    }
var d = d3.getDate()
    if(d&lt;10){
        d = &apos;0&apos;+d
    }
var res = `${y}年${m}月${d}日`;
console.log(res)

//四舍五入法
console.log(Math.round(-1.1))//1
console.log(Math.round(-1.5))//1
console.log(Math.round(-1.6))//2</code></pre><p>Math</p>
<pre><code>/方法：
Math.PI          II值
Math.e          常数e的值
Math.abs        绝对值
Math.max        最大值
Math.min        最小值
Math.floor      求小于参数的最大整数值
Math.ceil       求大于参数的最大整数值
Math.round      四舍五入
Math.pow        求次方
Math.sqrt       求平方根
Math.sin        正弦，它的参数是弧度，180度对应的Π值
Math.random     （0-1）之间的随机数值
parseInt(Math.random()*10)          (0-9)之间的随机整数
arr.indexOf(Math.max(...arr))    获取数组中的最值的位置</code></pre><p>Document全部方法</p>
<p>1 : Document 对象集合</p>
<pre><code>all[]                提供对文档中所有 HTML 元素的访问。
anchors[]            返回对文档中所有 Anchor 对象的引用。
applets                返回对文档中所有 Applet 对象的引用。
forms[]                返回对文档中所有 Form 对象引用。
images[]            返回对文档中所有 Image 对象引用。
links[]                返回对文档中所有 Area 和 Link 对象引用。</code></pre><p>2 : Document 对象属性</p>
<pre><code>body            提供对 &lt;body&gt; 元素的直接访问。对于定义了框架集的文档，该属性引用最外层的 &lt;frameset&gt;。
cookie            设置或返回与当前文档有关的所有 cookie。
domain            返回当前文档的域名。
lastModified    返回文档被最后修改的日期和时间。
referrer        返回载入当前文档的文档的 URL。
title            返回当前文档的标题。
URL                返回当前文档的 URL。</code></pre><p>BOM(浏览器窗口交互)</p>
<pre><code>/提供了独立于页面内容而与浏览器进行交互的对象，其内核对象是window
window在浏览器窗口中是所有对象的顶层对象
声明一个全局变量，就是为window对象的同名属性赋值</code></pre><p>检测用户所用的浏览器类型</p>
<p>1 : navigator（导航）</p>
<pre><code>/navigator.userAgent

var t = navigator.userAgent;
    if(t.indexOf(&apos;Trident&apos;)!= -1){
            console.log(&apos;ie内核&apos;)
    }else if(t.indexOf(&apos;Presto&apos;)!= -1){
            console.log(&apos;欧朋&apos;)
    }else if(t.indexOf(&apos;Chrome&apos;)!= -1){
            console.log(&apos;chrome &apos;)
    }else if(t.indexOf(&apos;Safari&apos;)!= -1){
            console.log(&apos;Safari &apos;)
    }else{
            console.log(&apos;其他&apos;)
    }</code></pre><p>2 : 判断是移动端还是PC端</p>
<pre><code>var ua = navigator.userAgent,toLowerCase();
if (ua.indexOf(&apos;mobi&apos;) !=-1) {
     // 手机浏览器
     console.log(&apos;手机&apos;)
    } else {
     // 非手机浏览器
     console.log(&apos;非手机&apos;)
    }</code></pre><p>3 : 判断移动端是安卓还是iphone</p>
<pre><code>var ub = navigator.userAgent.toLowerCase();
if(ub.indexOf(&apos;mobi&apos;)!=-1){
    //手机浏览器
    console.log(&apos;手机&apos;)
    if(ub.indexOf(&apos;android&apos;)!=-1){
        console.log(&apos;移动端 安卓&apos;)
    }else if(ub.indexOf(&apos;ipod&apos;)!=-1
        || ub.indexOf(&apos;iphone&apos;)!=-1
        || ub.indexOf(&apos;ipad&apos;)!=-1)
    {
        console.log(&apos;移动端 苹果手机&apos;)
    }
    }else{
    //非手机浏览器
        console.log(&apos;PC端&apos;)
    }</code></pre><p>3 . 1) : location(加载)</p>
<pre><code>//方法：addign(url),replace(url),reload()
assign()        加载新的文档
reload()        重新加载当前文档
replace()        用新的文档替换当前文档</code></pre><p>3 . 2) : location(访问)</p>
<pre><code>/location对象包含有关当前 URL 的信息。
//location对象是 Window 对象的一个部分，可通过 window.location 属性来访问。

属性：hash、host、hostname、href、pathname、port、protocol、search

href：        设置或返回完整的 URL。（常用）
hash：        设置或返回从井号 (#) 开始的 URL（锚）。
search：        设置或返回从问号 (?) 开始的 URL（查询部分？id=1&amp;name=abb）。（常用）

host            设置或返回主机名和当前 URL 的端口号。
hostname        设置或返回当前 URL 的主机名。
pathname        设置或返回当前 URL 的路径部分。
port            设置或返回当前 URL 的端口号。
protocol        设置或返回当前 URL 的协议。</code></pre><p>4 : 浏览器提示</p>
<pre><code>window.open()        打开一个新的浏览器窗口
window.close()        关闭浏览器窗口
alert(arg1)            显示带有一段消息和一个确认按钮的警告框
prompt(arg1,arg2)    显示可提示用户输入的输入框
confirm(arg1)        显示带有一段消息以及确认按钮和取消按钮的对话框</code></pre><p>4 . 1) : history（历史记录）</p>
<pre><code>/history对象保存着用户上网的历史纪录，从窗口被打开的那一刻算起

后退一页  history.go(-1) history.back()
前进一页  history.go(1) history.forward()
前进两页  history.go(2)</code></pre><p>4 . 2) : window.onload（页面加载完毕）</p>
<pre><code>/load时间发生在文档在浏览器窗口加载完毕时。
//window.onload属性可以置顶这个时间的回调函数。
window.onload = function(){
    console.log(&apos;页面加载完毕&apos;)
}；</code></pre><p>5 : 定时器和延时器</p>
<p>5 . 1) : 定时器</p>
<pre><code>//定时器
JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。</code></pre><p>5 . 2) : 延时器</p>
<pre><code>setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。
    var timerId = setTimeout(func, delay);
上面代码中，setTimeout函数接受两个参数，第一个参数func是将要推迟执行的函数名，第二个参数delay是推迟执行的毫秒数。
    console.log(1);
    //推迟执行
    setTimeout(function(){
        console.log(2)
    },1000);
        console.log(3);</code></pre><p>5 . 3) : 清除定时器</p>
<pre><code>/setTimeout和setInterval函数，都返回一个整数值，表示计数器编号。将该整数传入clearTimeout和clearInterval函数，
就可以取消对应的定时器。

//例：
var id1 = setTimeout(f,1000);
var id2 = setInterval(f,1000);

clearTimeout(id1);
clearInterval(id2);
两个定时器都被取消了</code></pre><p>6 : 顶部悬浮</p>
<pre><code>&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;num&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
var oDivs = document.getElementById(&quot;num&quot;);
window.onscroll = function(){
var scrollTop= document.documentElement.scrollTop
        || document.body.scrollTop;
console.log(scrollTop);
if(scrollTop &gt;= 450){
oDivs.style.position = &quot;fixed&quot;;
    }else{
        oDivs.style.position = &quot;static&quot;;
    }
}

在需要固定的div的css样式中加//top:0;</code></pre><p>7 : 返回顶部</p>
<pre><code>cursor: pointer;/* 光标变成指针 */

&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;num&quot;&gt;&amp;and;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
var aaa = document.getElementById(&apos;num&apos;)

aaa.onclick = function(){
document.documentElement.scrollTop = document.body.scrollTop = 0    
            }
window.onscroll = function(){
var scrollTop = document.documentElement.scrollTop
                ||document.body.scrollTop

    if(scrollTop&gt;400){
        console.log(2)
aaa.style.display = &quot;block&quot;
    }else{
        aaa.style.display = &quot;none&quot;
    }
}
&lt;/script&gt;</code></pre><p>DOM</p>
<pre><code>/Element.className
//className属性用来读写当前元素节点的class属性。它的值是一个字符串，每个class之间用空格分割。
HTML 代码 &lt;div class=&quot;one two three&quot; id=&quot;myDiv&quot;&gt;&lt;/div&gt;
var div = document.getElementById(&apos;myDiv&apos;);
div.className
&quot;one two three&quot;</code></pre><p>1 : Element.style (行内样式)</p>
<pre><code>/Element.style
//每个元素节点都有style用来读写该元素的行内样式信息不过，连词号需要变成骆驼拼写法。
var divStyle = document.querySelector(&apos;div&apos;).style;
divStyle.backgroundColor = &apos;red&apos;;
divStyle.border = &apos;1px solid black&apos;;
divStyle.width = &apos;100px&apos;;
divStyle.height = &apos;100px&apos;;
divStyle.fontSize = &apos;10em&apos;;

divStyle.backgroundColor // red
divStyle.border // 1px solid black
divStyle.height // 100px
divStyle.width // 100px
Element.style返回的只是行内样式，并不是该元素的全部样式。通过样式表设置的样式，或者从父元素继承的样式，无法通过这个属性得到。元素的全部样式要通过window.getComputedStyle()得到。</code></pre><p>2 : Element. get…(属性节点)</p>
<pre><code>/获取属性和设置属性（自定义属性）
    Element.getAttribute方法接受一个字符串作为参数，返回同名属性的值。如果没有该属性，则返回null。

    Element.setAttribute方法用于为当前节点设置属性。如果属性已经存在，将更新属性值，否则将添加该属性。该方法没有返回值。

&lt;button&gt;Hello World&lt;/button&gt;
var b = document.querySelector(&apos;button&apos;);
b.setAttribute(&apos;name&apos;, &apos;myButton&apos;);
b.setAttribute(&apos;disabled&apos;, true);

    Element.removeAttribute方法移除指定属性。该方法没有返回值。document.getElementById(&apos;div1&apos;).removeAttribute(&apos;id&apos;)</code></pre><p>3 : 标签</p>
<pre><code>outerHTML  //包括整个标签，而不仅限于标签内部的内容
innerHTML  //获取文本内容外面的标签
innerTEXT  //只获取元素内的文本内容，html标签将被忽略</code></pre><p>3 . 1) : 孩子节点</p>
<pre><code>/childNodes和children
Element.children属性返回一个类似数组的对象（HTMLCollection实例），包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员

这个属性与Node.childNodes属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。而childNodes属性包含空白节点</code></pre><p>3 . 2) : 高级选取</p>
<pre><code>//Element.firstElementChild属性返回当前元素的第一个元素子节点，Element.lastElementChild返回最后一个元素子节点。如果没有元素子节点，这两个属性返回null。

兄弟节点
     nextElementSibling  下一个节点        
     previousElementSibling  上一个节点   

Element.nextElementSibling属性返回当前元素节点的后一个同级元素节点，如果没有则返回null。   
Element.previousElementSibling属性返回当前元素节点的前一个同级元素节点，如果没有则返回null。
（分别对应的还有 firstChild，lastChild，nextSibling ，previousSibling方法 不过这些个方法都能获取到文本节点）

Element.parentNode可以获取父节点</code></pre><p>4 : 敏感词过滤</p>
<pre><code>consolo.log(&apos;aaa&apos;.replace(&apos;a&apos;,&apos;*&apos;))    replace把a换成*</code></pre><p>5 : 留言过滤</p>
<pre><code>btn5.onclick = function(){
    let str = `&lt;li&gt;${ipt5.value}&lt;/li&gt;`
    str = str.replace(/垃圾/g,&apos;**&apos;)
    list.innerHTML = list.innerHTML +str
}</code></pre><p>JavaScript常用DOM属性方法</p>
<pre><code>getElementById(id)              获取带有指定 id 的节点（元素）
getElementsByTagName()            返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。
getElementsByClassName()        返回包含带有指定类名的所有元素的节点列表。
appendChild(node)                  插入新的子节点（元素）
removeChild(node)                  删除子节点（元素）

onmouseover                     鼠标悬浮在文字上显示的内容
onmouseout                         鼠标移出时指定事件发生改变

innerHTML                          节点（元素）的文本值
parentNode                      节点（元素）的父节点
childNodes                        节点（元素）的子节点
attributes                      节点（元素）的属性节点

ownerDocument                      返回当前节点所在的顶层文档对象，即document
nextSibling                      返回紧跟在当前节点后面的第一个兄弟节点
previousSibling                  返回当前节点前面的、距离最近的一个兄弟节点
parentNode                       返回当前节点的父节点
parentElement                      返回当前节点的父Element节点
childNodes                       返回当前节点的所有子节点
firstChild                      返回当前节点的第一个子节点
lastChild                       返回当前节点的最后一个子节点
cloneNode(true);                  默认为false(克隆节点), true(克隆节点及其属性，以及后代)

replaceChild()                    替换子节点。
insertBefore()                    在指定的子节点前面插入新的子节点。
createAttribute()                创建属性节点。
createElement()                    创建元素节点。
createTextNode()                创建文本节点。
getAttribute()                    返回指定的属性值。
setAttribute()                    把指定属性设置或修改为指定的值。

//查找节点
document.querySelector(selectors)   //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。
document.querySelectorAll(selectors)  //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。
document.getElementsByTagName(tagName)  //返回所有指定HTML标签的元素
document.getElementsByClassName(className)   //返回包括了所有class名字符合指定条件的元素
document.getElementsByName(name)   //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）
document.getElementById(id)   //返回匹配指定id属性的元素节点。
document.elementFromPoint(x,y)  //返回位于页面指定位置最上层的Element子节点。

//生成节点
document.createElement(tagName)   //用来生成HTML元素节点。
document.createTextNode(text)   //用来生成文本节点
document.createAttribute(name)  //生成一个新的属性对象节点，并返回它。
document.createDocumentFragment()  //生成一个DocumentFragment对象

//事件方法
document.createEvent(type)   //生成一个事件对象，该对象能被element.dispatchEvent()方法使用
document.addEventListener(type,listener,capture)  //注册事件
document.removeEventListener(type,listener,capture)  //注销事件
document.dispatchEvent(event)  //触发事件</code></pre><p>1 : Element节点方法</p>
<p>1 . 1) : 位置方法</p>
<pre><code>getBoundingClientRect()  // getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高

getClientRects()   //返回当前元素在页面上形参的所有矩形。

// 元素在页面上的偏移量  
var rect = el.getBoundingClientRect()  
return {   
  top: rect.top + document.body.scrollTop,   
  left: rect.left + document.body.scrollLeft  
}</code></pre><p>1 . 2) : 属性方法</p>
<pre><code>Element.getAttribute()：读取指定属性  
Element.setAttribute()：设置指定属性  
Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性  
Element.removeAttribute()：移除指定属性</code></pre><p>1 . 3) : 查找方法</p>
<pre><code>Element.querySelector()  //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。
Element.querySelectorAll()  //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。
Element.getElementsByTagName()  //返回所有指定HTML标签的元素
Element.getElementsByClassName() //返回包括了所有class名字符合指定条件的元素
document.getElementsByName(name)   //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）
document.getElementById(id)   //返回匹配指定id属性的元素节点。
document.elementFromPoint(x,y)  //返回位于页面指定位置最上层的Element子节点。</code></pre><p>1 . 4) : 创建方法</p>
<pre><code>document.createElement(tagName)   //用来生成HTML元素节点。
document.createTextNode(text)   //用来生成文本节点
document.createAttribute(name)  //生成一个新的属性对象节点，并返回它。
document.createDocumentFragment()  //生成一个DocumentFragment对象

//获取，不是创建    
Element.className  //获取元素节点的类名</code></pre><p>1 . 5) : 事件方法</p>
<pre><code>Element.addEventListener()：添加事件的回调函数  
Element.removeEventListener()：移除事件监听函数  
Element.dispatchEvent()：触发事件</code></pre><p>1 . 6) : 其他插入方法</p>
<pre><code>//滚动条设置
Element.scrollIntoView()   //滚动当前元素，进入浏览器的可见区域

//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。
Element.insertAdjacentHTML(where, htmlString); 
Element.insertAdjacentHTML(&apos;beforeBegin&apos;, htmlString); // 在该元素前插入  
Element.insertAdjacentHTML(&apos;afterBegin&apos;, htmlString); // 在该元素第一个子元素前插入 
Element.insertAdjacentHTML(&apos;beforeEnd&apos;, htmlString); // 在该元素最后一个子元素后面插入 
Element.insertAdjacentHTML(&apos;afterEnd&apos;, htmlString); // 在该元素后插入

Element.remove()  //用于将当前元素节点从DOM中移除
Element.focus()   //用于将当前页面的焦点，转移到指定元素上</code></pre><p>对象事件</p>
<p>1 : 事件基础</p>
<pre><code>/JavaScript 事件是由访问 Web 页面的用户引起的一系列操作。
//当用户执行某些操作的时候，再去执行一系列代码。或者用来获取事件的详细信息，如鼠标位置、键盘按键等。 </code></pre><p>2 : 事件处理函数</p>
<pre><code>/javaScript可以处理的事件类型为：鼠标事件、键盘事件、HTML事件
//所有的事件处理函数都会都有两个部分组成，on + 事件名称</code></pre><p>2 . 1) : 鼠标事件</p>
<pre><code>/鼠标事件
onclick:                 鼠标单击
ondblclick:                 鼠标双击
onmousedown:             按下鼠标未抬起
onmouseup：                抬起鼠标按钮
onmouseover：            鼠标进入
onmouseout：                鼠标移出
onmousemove：            鼠标在元素上移动
onmouseenter              鼠标移入
oncontextmenu             鼠标右键点击

//表单事件
oninput                   是否输入
onblur                    失去焦点
onfocus                    获取焦点
onchange                内容修改




//鼠标位置事件
event.button            当前事件触发时哪个鼠标按键被点击
clientX、clientY       鼠标在可视区X坐标和Y坐标，即距离左边框和上边框的距离
screenX、screenY       鼠标在屏幕区X坐标和Y坐标，即距离左屏幕和上屏幕的距离
offsetX、offsetY      鼠标相对于事件源的X坐标和Y坐标
pageX、pageY          鼠标相对于文档的X坐标和Y坐标

在onmousemove事件中，设定目标元素的left和top，公式：
目标元素的left = 鼠标的clientX – （鼠标和元素的横坐标差，即offsetX）
目标元素的top = 鼠标的clientY– （鼠标和元素的纵坐标差，即offsetY）。

//详情请看--&gt;D盘--&gt;WEB 前端 全部文件--&gt;WEB第二阶段--&gt;第三周···</code></pre><p>2 . 2) : 键盘事件</p>
<pre><code>/键盘事件keyup、keydown、keypress

onkeydown：     键盘按键按下触发，如果按住不放，会重复触发
onkeyup：         键盘按键抬起
onkeypress：    键盘按下触发，如果按住不放，会重复触发
keyode:         表示对应的键盘上的键码
//组合键ctrkey、altkey、shiftkey
altKey属性，bool类型，表示发生事件的时候alt键是否被按下
ctrlKey属性，bool类型，表示发生事件的时候ctrl键是否被按下
shiftKey属性，bool类型，表示发生事件的时候shift键是否被按下 

//keyCode/which兼容
事件源（事件在哪个元素上产生）

//详情请看--&gt;D盘--&gt;WEB 前端 全部文件--&gt;WEB第二阶段--&gt;第三周···</code></pre><p>2 . 3) : 冒泡事件</p>
<pre><code>/事件的冒泡

事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。

//阻止事件冒泡
e.stopPropagation();

//低版本ie
e.cancelBubble = true;

/详情请看--&gt;D盘--&gt;WEB 前端 全部文件--&gt;WEB第二阶段--&gt;day11--&gt;PPT···</code></pre><p>2 . 4) : HTML事件onload</p>
<pre><code>onload：当页面加载完毕后触发
onselect：当用户选择文本框(input 或 textarea)中的一个或多个字符触发
onchange：当文本框(input 或 textarea)内容改变且失去焦点后触发
onfocus：当页面或者元素获得焦点时在 window 及相关元素上面触发    
onblur：当页面或元素失去焦点时在 window 及相关元素上触发
onresize：当窗口或框架的大小变化时在 window 或框架上触发
onscroll：当用户滚动带滚动条的元素时触发
OnchanLge:内容修改</code></pre><p>2 . 5) : 事件对象</p>
<pre><code>/事件对象

当触发某个事件时，会产生一个事件对象，这个对象包含着所有与事件有关的信息 。包括导致事件的元素、事件的类型、以及其它与特定事件相关的信息。

通过事件绑定的执行函数是可以得到一个隐藏参数的 。说明，浏览器会自动分配一个参数，这个参数其实就是 event 对象。

Event对象获取方式    （兼容性）
el.onclick=function(evt){
    let e = evt || window.event
}

/详情请看--&gt;D盘--&gt;WEB 前端 全部文件--&gt;WEB第二阶段--&gt;day11--&gt;PPT···</code></pre><p>addEventListener//添加事件监听</p>
<p>事件委托</p>
<pre><code>利用事件冒泡的原理，把本应添加给某元素上的事件委托给他的父级（外层）</code></pre><p>3 : 正则表达式</p>
<pre><code>/常用效果：邮箱。手机。身份证

是一个描述字符规则的对象，可以用来检测一个字符串是否包含某个子字符串，

构造函数
字面量</code></pre><p>4 : 创建方式</p>
<pre><code>一：
构造函数：
var reg = new RegExp(&quot;study&quot;,&quot;ig&quot;)

二：
字面量：
var reg = /study/ig;

i:表示忽略大小写(ignore)
g:表示全局匹配，查找所有匹配而非再找到第一个匹配后停止(global)

//exec() 方法用于检索字符串中的正则表达式的匹配。
//RegExp 对象用于规定在文本中检索的内容。
//replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</code></pre><p>ES6(var 全局变量    let块级变量)</p>
<p>1 : 单词方法</p>
<pre><code>new Set 数组去重
Array.from 转换为一个新数组</code></pre><p>2 : this关键字</p>
<pre><code>/&quot;this&quot;定义
    this 可以用在构造函数中，表示实例对象。除此之外，this还可以用在别的唱歌，但不管是称么场合，他都有一个共同点：它总是返回一个对象

    this 就是属性或方法&quot;当前&quot;所在的对象

//用法：
    var person = {
          name: &apos;张三&apos;,
          describe: function () {
    return &apos;姓名：&apos;+ this.name;
  }};

person.describe()// &quot;姓名：张三&quot;</code></pre><p>2 . 1) : “this”使用场合</p>
<p>(1)全局变量</p>
<pre><code>(1)全局变量</code></pre><p>(2)对象的方法</p>
<pre><code>/bind 方法用于将函数体内的this绑定到某个对象，然后返回一个新函数

    var dog ={
        name:&apos;wangcai&apos;,
        age:18,
        wang:function(){
            console.log(this)
        }
    }
    var person = {name:&apos;小明&apos;}
    var func = dog.wang.bind(person)
    func();
//上面代码将person绑定了dunc函数内部</code></pre><p>3 : let/const</p>
<p>let 用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效</p>
<pre><code>{
    let a = 10;
    var b = 0
}
a//ReferenceError: a is not defined.
b//1

//打印后let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。</code></pre><p>4: const命令</p>
<pre><code>&quot;const&quot;声明一个只读的常量。一旦声明，常量的值就不能改变
&quot;const&quot;声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值

const PI = 3.1415
PI// 3.1415

PI = 3
//报错
//上面代码表明改变常量的值会报错</code></pre><p>5 : 箭头函数  =&gt;</p>
<pre><code>var f = v =&gt; v;
//等同于
var f = function (v){
    return v
}


//如果箭头函数不需要参数或需要多个承诺书，就使用一个圆括号代表参数部分。
例1：
var f = () =&gt; 5;
//等同于
var f = function(){
    return 5
}

例2：
var sum = (num1,num2) =&gt; num1 + num2;
//等同于
var sum = function(num1,num2){
    return num1 + num2
}


//如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。
例1：
var sum = (num1, num2) =&gt; { return num1 + num2; }



//箭头函数使得表达更加简洁
const isEven = n =&gt; n % 2 == 0;
const square = n =&gt; n * n;



//箭头函数的一个用处是简化回调函数。
// 正常函数写法
[1,2,3].map(function (x) {
  return x * x;});
// 箭头函数写法
[1,2,3].map(x =&gt; x * x);

// 正常函数写法
var result = values.sort(function (a, b) {
  return a - b;});
// 箭头函数写法
var result = values.sort((a, b) =&gt; a - b);


箭头函数有几个使用注意点。
（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
（3）不可以使用arguments对象，该对象在函数体内不存在。</code></pre><p>6 : 字符串扩展</p>
<p>模板字符串（template string）是增强版的字符串 </p>
<pre><code>ar a = 1
var b = 2;
var sum = a + b;
var res = a + &apos;+&apos; + b + &apos;的和是&lt;b&gt;&apos; + c+&apos;&lt;/b&gt;&apos;;
console.log(res)
//上面的能写成下面这样
var a = 1
var b = 2;
var sum = a + b;
var res = `a+b的和是&lt;b&gt;${c}&lt;/b&gt;`;
console.log(res)


includes()：返回布尔值，表示是否找到了参数字符串。
startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部</code></pre><p>7 : 数组新增方法</p>
<pre><code>/Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（ES6 新增的数据结构 Set 和 Map）
//下面是一个类似数组的对象，Array.from将它转为真正的数组
let arrayLike = {
    &apos;0&apos;: &apos;a&apos;,
    &apos;1&apos;: &apos;b&apos;,
    &apos;2&apos;: &apos;c&apos;,
    length: 3};

let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]

简洁属性
const foo = &apos;bar&apos;;
const baz = {foo};
baz // {foo: &quot;bar&quot;}
// 等同于
const baz = {foo: foo};

简洁方法
const o = {
  method() {
    return &quot;Hello!&quot;;
  }
};

// 等同于
const o = {
  method: function() {
    return &quot;Hello!&quot;;
  }
}</code></pre><p>8 : 扩展运算符三个点（…）</p>
<pre><code>/对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }

由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。
let foo = { ...[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] };
foo
// {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;}

对象的扩展运算符等同于使用Object.assign()方法。
let aClone = { ...a };
// 等同于
let aClone = Object.assign({}, a);


{
function add(x, y) { 
return x + y; 
} 
var numbers = [4, 38]; 
add(...numbers) //

//该运算符将一个数组，变为参数序列
}

{
 var arr1 = [&apos;a&apos;, &apos;b&apos;];
 var arr2 = [&apos;c&apos;];
 var arr3 = [&apos;d&apos;, &apos;e&apos;];
// 合并数组
 [...arr1, ...arr2, ...arr3]
}</code></pre><p>9 : 函数参数默认值</p>
<pre><code>function log(x, y) {
  y = y || &apos;World&apos;;
  console.log(x, y);}

log(&apos;Hello&apos;) // Hello World
log(&apos;Hello&apos;, &apos;China&apos;) // Hello China

 //这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。

`````````````````````````````````````````````````````````````````````````````
function log(x, y = &apos;World&apos;) {
  console.log(x, y);}

log(&apos;Hello&apos;) // Hello World
log(&apos;Hello&apos;, &apos;China&apos;) // Hello China
可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。</code></pre><p>10 : Symbol类型</p>
<pre><code>let a = 1;
let b = 2;
console.log(a==b)//打印false

let s1 = Symbol(&apos;s1&apos;)
let s2 = Symbol(&apos;s2&apos;)

console.log(s1 === s2)//打印false
console.log(typeof s1)//Symbol
console.log(s1,s2)

let s3 = Symbol()//Symbol 数据类型的特点是唯一性，即使是用同一个变量生成的值也不相等。
let obj = {
    username:&apos;aaa&apos;,
    [s3]:&apos;ccc&apos;
}

//取字符串属性username
console.log(obj.username)//打印aaa
console.log(obj[&apos;username&apos;])//打印aaa

obj.age = &apos;111&apos;

obj[s1] = &apos;9999&apos;
obj[s2] = &apos;1000&apos;
console.log(obj)//打印以上所有数组的内容

console.log(obj.s1)//undefined
console.log(obj[s1])//打印999
console.log(obj[s3])//打印ccc</code></pre><p>11 ：作用域</p>
<p>11 . 1) : 局部作用域</p>
<pre><code>/局部变量（形参都是局部变量）

使用var 在函数内部定义的变量
使用let或者const在代码块中定义的变量</code></pre><p>11 . 2) : 全局作用域</p>
<pre><code>/全局变量（在函数外部声明）

全局变量会被同名的局部变量覆盖</code></pre><p>数组去重方法</p>
<pre><code>// 方法一
//利用for嵌套for，然后splice去重
function aa(arr) {
    for (var i = 0; i &lt; arr.length; i++) {
        for (var j = i + 1; j &lt; arr.length; j++) {
            if (arr[i] == arr[j]) {
                arr.splice(j, 1);
                j--;
            }
        }
    }
    return arr;
}
var arr = [1,1,15,15,0,0,];
console.log(aa(arr))




// 方法二
//利用ES6 Set去重
function bb(arr) {
    return Array.from(new Set(arr))
}
var arr = [1,1,15,15,0,0,];
console.log(bb(arr))





// 方法三
//利用indexOf去重
function cc(arr) {
    if (!Array.isArray(arr)) {
        console.log(&apos;type error!&apos;)
        return
    }
    var array = [];
    for (var i = 0; i &lt; arr.length; i++) {
        if (array .indexOf(arr[i]) === -1) {
            array .push(arr[i])
        }
    }
    return array;
}
var arr = [1,1,15,15,0,0,];
console.log(cc(arr))




// 方法四
//利用sort()去重
function dd(arr) {
    if (!Array.isArray(arr)) {
        console.log(&apos;type error!&apos;)
        return;
    }
    arr = arr.sort()
    var arrry= [arr[0]];
    for (var i = 1; i &lt; arr.length; i++) {
        if (arr[i] !== arr[i-1]) {
            arrry.push(arr[i]);
        }
    }
    return arrry;
}
     var arr = [1,1,15,15,0,0,];
        console.log(dd(arr))




// 方法五
//利用对象的属性不能相同的特点进行去重
function ee(arr) {
    if (!Array.isArray(arr)) {
        console.log(&apos;type error!&apos;)
        return
    }
    var arrry= [];
     var  obj = {};
    for (var i = 0; i &lt; arr.length; i++) {
        if (!obj[arr[i]]) {
            arrry.push(arr[i])
            obj[arr[i]] = 1
        } else {
            obj[arr[i]]++
        }
    }
    return arrry;
}
    var arr = [1,1,15,15,0,0,];
        console.log(ee(arr))





// 方法六
//利用includes
function ff(arr) {
    if (!Array.isArray(arr)) {
        console.log(&apos;type error!&apos;)
        return
    }
    var array =[];
    for(var i = 0; i &lt; arr.length; i++) {
            if( !array.includes( arr[i]) ) {
                //includes 检测数组是否有某个值
                    array.push(arr[i]);
              }
    }
    return array
}
var arr = [1,1,15,15,0,0,];
    console.log(ff(arr))






// 方法七
//利用filter
function gg(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
var arr = [1,1,15,15,0,0,];
console.log(gg(arr))







// 方法八
//利用递归去重
function hh(arr) {
        var array= arr;
        var len = array.length;

    array.sort(function(a,b){   //排序后更加方便去重
        return a - b;
    })

    function loop(index){
        if(index &gt;= 1){
            if(array[index] === array[index-1]){
                array.splice(index,1);
            }
            loop(index - 1);    //递归loop，然后数组去重
        }
    }
    loop(len-1);
    return array;
}
 var arr = [1,1,15,15,0,0,];
console.log(hh(arr))





// 方法九
//利用Map数据结构去重
function arrayNonRepeatfy(arr) {
  let map = new Map();
  let array = new Array();  // 数组用于返回结果
  for (let i = 0; i &lt; arr.length; i++) {
    if(map .has(arr[i])) {  // 如果有该key值
      map .set(arr[i], true); 
    } else { 
      map .set(arr[i], false);   // 如果没有该key值
      array .push(arr[i]);
    }
  } 
  return array ;
}
var arr = [1,1,15,15,0,0,];
console.log(unique(arr))






// 方法十
//利用reduce+includes
function unique(arr){
    return arr.reduce((prev,cur) =&gt; prev.includes(cur) ? prev : [...prev,cur],[]);
}
var arr = [1,1,15,15,0,0,];
console.log(unique(arr));




// 方法十一
//利用[...new Set(arr)]
1.
let s1 = new Set([1,2,3,1,2,3])
console.log(s1)

2.
let arr = [1,2,3,4,1]
console.log(Array.from(new Set(arr)))

3.
var arr = [1,1,15,15,0,0,];
console.log([...new Set(arr)])</code></pre><p>高级  运动</p>
<p>1 : 匀速运动</p>
<pre><code>匀速运动
1:运动原理setInterval

&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;


            let box = document.querySelector(&apos;#box&apos;)
            box.timer = setInterval(()=&gt;{
                box.isRunning = true;
                box.style.left = box.offsetLeft + 5 +&apos;px&apos;
            },80)
            document.onclick = function(){
                if(box.isRunning==true){
                    clearInterval(box.timer)
                    box.isRunning = false;
                }else{
                    box.timer = setInterval(()=&gt;{
                        box.isRunning = true;
                    box.style.left = box.offsetLeft + 5 + &apos;px&apos;
                    },80)
                }
                console.log(box.timer)
            }</code></pre><p>2 : 边界处理</p>
<pre><code>2.边界处理
遇到边界是应该停止环视反弹
改变物体运动方向：将物体的速度值取反

            &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;

            let box = document.querySelector(&apos;#box&apos;)
            let speedX = 15;
            let speedY = 15;
            let dri = &apos;left&apos;;
            let dri2 = &apos;top&apos;;
            box.timer = setInterval(()=&gt;{
                box.isRunning = true;
                box.style[dri] = parseFloat(getComputedStyle(box)[dri]) + speedX + &apos;px&apos;
                box.style[dri2] = parseFloat(getComputedStyle(box)[dri2]) + speedY + &apos;px&apos;

                console.log(getComputedStyle(box).width)
                console.log(getComputedStyle(box).left)

                if (parseFloat(getComputedStyle(box)[&apos;left&apos;]) &gt;= document.documentElement.clientWidth - box.offsetWidth) {
                    speedX *= -1
                }
                if (parseFloat(getComputedStyle(box)[&apos;left&apos;]) &lt;= 0) {
                    speedX *= -1
                }
                if (parseFloat(getComputedStyle(box)[&apos;top&apos;]) &gt;= document.documentElement.clientHeight - box.offsetWidth) {
                    speedY *= -1
                }
                if (parseFloat(getComputedStyle(box)[&apos;top&apos;]) &lt;= 0) {
                    speedY *= -1
                }
            },40)</code></pre><p>3 : 加速减速</p>
<pre><code>3.加速减速
加速：速度越来越快
减速：速度越来越慢
            let box = document.querySelector(&apos;#box&apos;)
            let speedX = 30;
            let speedY = 0;
            let dri = &apos;left&apos;
            let dri2 = &apos;top&apos;
            box.timer = setInterval(()=&gt;{
                box.style[dri] = parseFloat(getComputedStyle(box)[dri]) + speedX + &apos;px&apos;
                box.style[dri2] = parseFloat(getComputedStyle(box)[dri2]) + speedY + &apos;px&apos;

                speedY = speedY + 10
            },800)</code></pre><p>4 : 抛物线</p>
<pre><code>水平方向有一速度，垂直方向有一速度，并做自由落体
var speedY = 0;
var speedX = 10;
// x 方向  匀速
// y 方向  匀加速
                let box = document.querySelector(&apos;#box&apos;)
            let speedX = 35;
            let speedY = 0;
            let dri = &apos;left&apos;
            let dri2 = &apos;top&apos;

            let x = 0;
            let y = 1;
            box.timer = setInterval(()=&gt;{
                console.log(x,y)
                box.style[dri] = x + &apos;px&apos;
                box.style[dri2] = y + &apos;px&apos;

                x = x + 5;
                y = 0.002*x*x + 1
            },80)</code></pre><p>5 : 透明度   轮播</p>
<pre><code>#box {
        width: 220px;
        height: 220px;
        background: red;
        position: absolute;
    }

&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;box2&quot;&gt;&lt;/div&gt;    

    let box = document.querySelector(&apos;#box&apos;)

    let op = 1
    box.timer = setInterval(()=&gt;{
        op-=0.08
        box.style.opacity = op
    },100)

    let op2 = 0
    box2.timer = setInterval(()=&gt;{
        op2+=0.08
        box2.style.opacity = op2
    },100)</code></pre><p>6 : 缓冲运动</p>
<pre><code>速度一开始很大，然后慢慢变小，比较类似自然界中得缓冲运动
            &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;

            let box = document.querySelector(&apos;#box&apos;)

            let dri = &apos;width&apos;
            let target = 500;//元素的长度
            box.timer = setInterval(() =&gt; {//匀速运动
                //元素整体长度减去后面要伸展的长度,20表示速度
                let speed = (target - parseFloat(getComputedStyle(box)[dri])) / 20
                if (speed &gt; 0) {
                    speed = Math.ceil(speed)
                } else {
                    speed = Math.floor(speed)
                }
                box.style[dri] = parseFloat(getComputedStyle(box)[dri]) + speed + &apos;px&apos;

                console.log(speed)
                if (parseFloat(getComputedStyle(box)[dri]) == target) {
                    clearInterval(box.timer)
                }
            }, 70)</code></pre><p>面向对象（贼难）</p>
<p>定义</p>
<pre><code>面向对象是什么？</code></pre><p>特点（封装，继承，多态）</p>
<p>抽象</p>
<pre><code>抽象：抽象和问题相关的东西
对学生而言：学生管理系统  关注点在：学生成绩，学生分数</code></pre><p>封装</p>
<pre><code>1.用对象：
2.写对象（类）</code></pre><p>继承</p>
<pre><code>单继承
多重继承：继承好多份遗产</code></pre><p>对象的组成</p>
<p>1 ： 方法</p>
<pre><code>element   vant</code></pre><p>2 ： 属性</p>
<p>属性本质就是变量</p>
<p>难记词</p>
<pre><code>animate     创建动画效果，自定义动画    
target      事件属性，可饭hi事件的目标节点
parseFloat()     函数可解析一个字符串，并返回一个浮点
speed        控制方法执行速度
getComputedStyle    可用来获取元素中所有可用的cssYANGSHI 属性列表
scrollintoView()     是一个与页面（容器）滚动相关的
createElement        创建
localstorge            用来作为本地存储使用
btnEvents            按钮事件处理
constructor            属性返回对创建此对象的数组函数的引用

Math对象  用于执行数学函数
//例：
vara pi_value=Math.PI;
var sqrt_value=Math.sqrt(15);</code></pre><p>localStorage</p>
<p>想要存对象或数组必须要先转换为json字符串才有意义</p>
<p>不然会转成tostring类型</p>
<p>不能跨域名读取文件</p>
<p>1 : localStorage的写入</p>
<pre><code>var storage = window.localStorage
//写入a字段
storage[&quot;a&quot;]=1;
//写入a字段
storage.a=1;
//写入a字段
storage.setItem(&quot;c&quot;,3)</code></pre><p>2 : localStorage的读取</p>
<pre><code>//第一种方法读取
var a=storage.a;
console.log(a);
//第二种方法读取
var b=storage[&quot;b&quot;];
console.log(b);
//第三种方法读取
var c=storage.getItem(&quot;c&quot;);
console.log(c)</code></pre><p>3 : localStorage的修改</p>
<pre><code>var storage=window.localStorage;
//写入a字段
storage[&quot;a&quot;]=1;
storage.a=4; //修改
console.log(storage.a)

localStorage.removeItem(&apos;username&apos;)//删除
localStorage.clear()//清空

如果存的是数组或对象，要修改的话，先读取处理，再转换对象，再修改，再村</code></pre><p>4 : localStorage的删除</p>
<pre><code>storage.setItem(&quot;c&quot;,3);
console.log(storage);
storage.removeItem(&quot;a&quot;);

//将localStorage的所有内容清除
storage.clear();</code></pre><p>5 : localStorage的清空</p>
<pre><code>storage.clear();    清空所有内容</code></pre><p>6 : localStorage其他注意事项</p>
<pre><code>/一般我们会将JSON(js中的对象)存入localStorage中，但是在localStorage会自动将localStorage转换成为字符串形式，这个时候我们可以使用JSON.stringify()这个方法，来将JSON转换成为JSON字符串


var data={
    name:&apos;zhangsan&apos;,
    sex:&apos;man&apos;,
};
var d=JSON.stringify(data);
storage.setItem(&quot;data&quot;,d);
//将JSON字符串转换成为JSON对象输出
var json=storage.getItem(&quot;data&quot;);
var jsonObj=JSON.parse(json);</code></pre><p>Mysql</p>
<p>1 : 概念</p>
<pre><code>//数据库（数据库，表，主键）
    数据库: 数据库是一些关联表的集合
     数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。（类似Excel表格）
     主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。（类似人的身份证信息）</code></pre><p>2 : 数据类型</p>
<pre><code>MYSQL支持多种类型，大致可以分为三类：数值，日期/时间和字符串（字符）类型。</code></pre><p>2 . 1数值类型</p>
<pre><code>INT或INTEGER大整数值
decimal类型可以精确地表示非常大或非常精确的小数，勇敢与定义货币要求精确度高的数据</code></pre><p>2 . 2字符串类型</p>
<pre><code>VARCHAR变长字符串</code></pre><p>2 . 3日期或事件类型</p>
<pre><code>DATEIME混合日期和世间值  格式YYYY-MM-DD HH:MM:SS</code></pre><p>网络协议</p>
<pre><code>tcp   有链接  稳定  安全  三次握手
udp   无连接  不安全   但是传输速度快  一般都在游戏运用

ajax  一般向服务器要json数据，向服务器请求数据
优点：不用刷新网页就可以要的数据
异步请求
XMLHttpRequest变量对象

ajax的优势：
1.不用刷新当前页面就可以要的数据
2.异步和服务器通信（不让界面卡顿）
3.基于标准背广泛支持
4.界面与应用分离（前后端分离）
5。节省带宽（流量）


发起一个xhr请求
请求一个网络地址 api接口  url（请求服务器）

异步请求不能用返回值接收数据
responseText  响应文本

//请求结束的时候， onload函数自动执行，就可以拿到数据
xhr.onload = function(){
    console.log(xhr.responseText)

    把字符串转换成对象
}</code></pre>
      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1499641973@qq.com </span>
    </div>
</article>


<p>
    <a href="javascript:void(0)" target="_blank" rel="noopener" class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>JS笔记</p>
    
    <p><span class="copy-title">本文作者:</span><a href="javascript:void(0)" target="_blank" rel="noopener" title="穿着校服拽天下">穿着校服拽天下</a></p>
    <p><span class="copy-title">发布时间:</span>2019-11-06, 14:37:08</p>
    <p><span class="copy-title">最后更新:</span>2019-11-13, 21:02:46</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2019/11/06/JavaScript/" title="JS笔记">http://yoursite.com/2019/11/06/JavaScript/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 Yelog</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" href="javascript:void(0)" target="_blank" rel="noopener"></a>
    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close" href="javascript:void(0)" target="_blank" rel="noopener" onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#H5+CSS','#git','#API','#规范','#框架','#面试','#JS','#Vue','#ajax','#Js','#code','#React','#Webpack','#Other','#VUE','#前端路由','#JavaScript',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
